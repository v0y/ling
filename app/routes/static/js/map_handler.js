// Generated by CoffeeScript 1.6.3
(function() {
  MapHandler = (function() {
    function MapHandler() {}

    MapHandler.prototype.mode = 'gpx';
    MapHandler.prototype.map = null;

    MapHandler.prototype.routes = [];

    MapHandler.prototype.initializeMap = function() {
      var mapOptions;
      mapOptions = {
        center: new google.maps.LatLng(15, 15),
        zoom: 3,
        mapTypeId: google.maps.MapTypeId.ROADMAP
      };
      return this.map = new google.maps.Map($("#map-canvas")[0], mapOptions);
    };

    MapHandler.prototype.addRoute = function(routeJson) {
      var route;
      route = new Route();
      route.tracks = routeJson;
      route.map = this.map;
      route.draw();
      this.routes.push(route);
      return this.getDistanceAndTimes();
    };

    MapHandler.prototype.clearRoutes = function() {
      var route, _i, _len, _ref, _results;
      _ref = this.routes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        route = _ref[_i];
        _results.push(route.clear());
      }
      return _results;
    };

    MapHandler.prototype.singleNewRoute = function(routeJson) {
      this.clearRoutes();
      return this.addRoute(routeJson);
    };

    MapHandler.prototype.getDistanceAndTimes = function() {
      var durationSeconds, route, _i, _len, _ref;
      this.distance = 0;
      this.startTime = this.routes[0].startTime;
      this.endTime = this.routes[0].startTime;
      _ref = this.routes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        route = _ref[_i];
        if (route.startTime < this.startTime) {
          this.startTime = route.startTime;
        }
        if (route.endTime > this.endTime) {
          this.endTime = route.endTime;
        }
        this.distance += route.distance;
      }
      durationSeconds = this.endTime.diff(this.startTime, 'seconds');
      return this.duration = moment.duration(durationSeconds, 'seconds');
    };

    MapHandler.prototype.toggleManualRouteDrawing = function() {
      switch (this.mode) {
        case 'gpx':
          return this.initializeManualRouteHandling();
        case 'manual':
          return this.finishManualRouteHandling();
      }
    };

    MapHandler.prototype.initializeManualRouteHandling = function() {
      this.clearRoutes();
      if (!this.manualRouteHandler) {
        this.manualRouteHandler = new ManualRouteHandler();
        console.log(this.manualRouteHandler);
        this.manualRouteHandler.map = this.map;
        this.manualRouteHandler.initialize();
      }
      this.manualRouteHandler.turnOn();
      return console.log("<<< - - - >>>");
    };

    MapHandler.prototype.finishManualRouteHandling = function() {
      this.manualRouteHandler.turnOff();
      return console.log('clearManualRouteHandling');
    };

    return MapHandler;

  })();

  Route = (function() {
    function Route() {}

    Route.prototype.map = null;

    Route.prototype.tracks = null;

    Route.prototype.polylines = [];

    Route.prototype.mapPoints = [];

    Route.prototype.distance = 0;

    Route.prototype.fullKmSectionsList = [];

    Route.prototype.startMarker = null;

    Route.prototype.finishMarker = null;

    Route.prototype.fullKmMarkers = [];

    Route.prototype.draw = function() {
      var fullKmSectionsList;
      this.drawTracks();
      this.addStartFinishMarkers();
      fullKmSectionsList = this.getRouteDistance();
      this.drawFullKmMarkers(fullKmSectionsList);
      return this.getStartFinishTimes();
    };

    Route.prototype.clear = function() {
      var marker, polyline, _i, _j, _len, _len1, _ref, _ref1, _results;
      _ref = this.fullKmMarkers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        marker = _ref[_i];
        marker.setMap(null);
      }
      this.startMarker.setMap(null);
      this.finishMarker.setMap(null);
      _ref1 = this.polylines;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        polyline = _ref1[_j];
        _results.push(polyline.setMap(null));
      }
      return _results;
    };

    Route.prototype.drawTracks = function() {
      var latlngbounds, point, polyline, pt, segment, segmentMapPoints, track, trackMapPoints, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
      latlngbounds = new google.maps.LatLngBounds();
      _ref = this.tracks;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        track = _ref[_i];
        trackMapPoints = [];
        _ref1 = track['segments'];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          segment = _ref1[_j];
          segmentMapPoints = [];
          for (_k = 0, _len2 = segment.length; _k < _len2; _k++) {
            point = segment[_k];
            pt = new google.maps.LatLng(point['lat'], point['lon']);
            segmentMapPoints.push(pt);
            latlngbounds.extend(pt);
          }
          polyline = new google.maps.Polyline({
            path: segmentMapPoints,
            editable: false,
            draggable: false,
            geodesic: true,
            strokeColor: '#FF0000',
            strokeOpacity: 1.0,
            strokeWeight: 2
          });
          polyline.setMap(this.map);
          this.polylines.push(polyline);
          trackMapPoints.push(segmentMapPoints);
        }
        this.mapPoints.push(trackMapPoints);
      }
      return this.map.fitBounds(latlngbounds);
    };

    Route.prototype.addStartFinishMarkers = function() {
      var finishInfoWindow, routePoints, startInfoWindow, trackPoints,
        _this = this;
      this.startMarker = new google.maps.Marker({
        position: this.mapPoints[0][0][0],
        map: this.map,
        title: "Start"
      });
      routePoints = this.mapPoints[this.mapPoints.length - 1];
      trackPoints = routePoints[routePoints.length - 1];
      this.finishMarker = new google.maps.Marker({
        position: trackPoints[trackPoints.length - 1],
        map: this.map,
        title: "Koniec"
      });
      finishInfoWindow = new google.maps.InfoWindow({
        content: "<span>Koniec</span>"
      });
      startInfoWindow = new google.maps.InfoWindow({
        content: "<span>Start</span>"
      });
      google.maps.event.addListener(this.startMarker, 'click', function() {
        finishInfoWindow.close();
        return startInfoWindow.open(_this.map, _this.startMarker);
      });
      return google.maps.event.addListener(this.finishMarker, 'click', function() {
        startInfoWindow.close();
        return finishInfoWindow.open(_this.map, _this.finishMarker);
      });
    };

    Route.prototype.getRouteDistance = function() {
      var distance, fullKmSectionsList, _ref;
      _ref = getTotalDistance(this.tracks), distance = _ref[0], fullKmSectionsList = _ref[1];
      this.distance = distance;
      return fullKmSectionsList;
    };

    Route.prototype.getStartFinishTimes = function() {
      var endTimeString, lastSegment, lastTracks, startTimeString;
      startTimeString = this.tracks[0].segments[0][0].time;
      this.startTime = moment(startTimeString, 'YYYY-MM-DD HH:mm:ss');
      lastTracks = this.tracks[this.tracks.length - 1].segments;
      lastSegment = lastTracks[lastTracks.length - 1];
      endTimeString = lastSegment[lastSegment.length - 1].time;
      this.endTime = moment(endTimeString, 'YYYY-MM-DD HH:mm:ss');
      return this.totalTime = this.endTime.diff(this.startTime, 'minutes');
    };

    Route.prototype.drawFullKmMarkers = function(fullKmSectionsList) {
      _results = [];
      for (_i = 0, _len = fullKmSectionsList.length; _i < _len; _i++) {
        section = fullKmSectionsList[_i];
        start = Math.ceil(section.startDistance);
        pt1ToFullKmDistance = start - section.startDistance;
        kmsToMark = [];
        while (start < Math.floor(section.endDistance + 1)) {
          kmsToMark.push(start);
          start += 1;
        }
        i = 0;
        _results.push((function() {
          var _j, _len1, _ref, _results1;
          _results1 = [];
          for (_j = 0, _len1 = kmsToMark.length; _j < _len1; _j++) {
            km = kmsToMark[_j];
            _ref = getPointOnSection(section, pt1ToFullKmDistance, i), lat = _ref[0], lon = _ref[1];
            latlng = new google.maps.LatLng(lat, lon);
            image = {
              url: "http://www.markericons.eu/ico?file=903f5ca84d5043e8998f379fe6fe8608.png&txt=" + markerCounter + "km&fs=10"
            };
            marker = new google.maps.Marker({
              position: latlng,
              map: this.map,
              icon: image
            });
            this.fullKmMarkers.push(marker);
            _results1.push(markerCounter += 1);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    return Route;

  })();

  ManualRouteHandler = (function() {
    function ManualRouteHandler() {}

    ManualRouteHandler.prototype.map = null;

    ManualRouteHandler.prototype.route = null;

    ManualRouteHandler.prototype.markers = [];

    ManualRouteHandler.directionsService = null;

    ManualRouteHandler.directionsDisplay = null;

    ManualRouteHandler.prototype.staraightRoutePolyline = null;

    ManualRouteHandler.prototype.messageAreaSelector = '.js-message-area';

    ManualRouteHandler.prototype.initialize = function() {
      this.directionsService = new google.maps.DirectionsService();
      this.directionsDisplay = new google.maps.DirectionsRenderer({
        draggable: true
      });
      return this.directionsDisplay.setMap(this.map);
    };

    ManualRouteHandler.prototype.turnOn = function() {
      var _this;
      _this = this;
      return this.mapListenerHandle = google.maps.event.addListener(this.map, 'click', function(point) {
        var marker;
        marker = new google.maps.Marker({
          position: point.latLng,
          map: _this.map,
          draggable: true
        });
        _this.markers.push(marker);
        google.maps.event.addListener(marker, 'rightclick', function() {
          var i, _i, _ref;
          marker.setMap(null);
          for (i = _i = 0, _ref = _this.markers.length; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
            if (marker === _this.markers[i]) {
              _this.markers.splice(i, 1);
              break;
            }
          }
          return _this.drawStraightLinesRoute();
        });
        google.maps.event.addListener(marker, 'drag', function() {
          return _this.drawStraightLinesRoute();
        });
        return _this.extendRoute();
      });
    };

    ManualRouteHandler.prototype.turnOff = function() {
      return google.maps.event.removeListener(this.mapListenerHandle);
    };

    ManualRouteHandler.prototype.extendRoute = function() {
      var markersLen;
      console.log('extendRoute');
      console.log(this.markers);
      markersLen = this.markers.length;
      if (markersLen < 2) {
        return;
      }
      return this.drawStraightLinesRoute();
    };

    ManualRouteHandler.prototype.drawStraightLinesRoute = function() {
      var marker, path, _i, _len, _ref;
      if (this.staraightRoutePolyline) {
        this.staraightRoutePolyline.setMap(null);
      }
      path = [];
      _ref = this.markers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        marker = _ref[_i];
        path.push(marker.position);
      }
      this.staraightRoutePolyline = new google.maps.Polyline({
        path: path,
        geodesic: true,
        strokeColor: '#FF0000',
        strokeOpacity: 1.0,
        strokeWeight: 2
      });
      return this.staraightRoutePolyline.setMap(this.map);
    };

    ManualRouteHandler.prototype.routeFromGoogle = function() {
      var request, _this;
      request = {
        origin: this.markers[markersLen - 2].position,
        destination: this.markers[markersLen - 1].position,
        travelMode: google.maps.TravelMode.WALKING,
        optimizeWaypoints: false,
        provideRouteAlternatives: false,
        region: 'pl'
      };
      _this = this;
      console.log([this, 'this']);
      return this.directionsService.route(request, function(response, status) {
        if (status === google.maps.DirectionsStatus.OK) {
          return console.log(response);
        }
      });
    };

    return ManualRouteHandler;

  })();

  getTotalDistance = function(routes) {
    var distance, fullKmDistance, fullKmSectionsList, i, obj, pt1, pt2, route, segment, x, _i, _j, _k, _len, _len1, _ref, _ref1;
    distance = 0;
    fullKmSectionsList = [];
    fullKmDistance = 0;
    for (_i = 0, _len = routes.length; _i < _len; _i++) {
      route = routes[_i];
      _ref = route['segments'];
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        segment = _ref[_j];
        for (i = _k = 1, _ref1 = segment.length - 1; 1 <= _ref1 ? _k <= _ref1 : _k >= _ref1; i = 1 <= _ref1 ? ++_k : --_k) {
          pt1 = segment[i - 1];
          pt2 = segment[i];
          x = get2PointsDistance(pt1, pt2);
          if (Math.floor(distance + x) > fullKmDistance) {
            obj = {
              startPoint: pt1,
              startDistance: distance,
              endPoint: pt2,
              endDistance: distance + x
            };
            fullKmSectionsList.push(obj);
            fullKmDistance = Math.floor(distance + x);
          }
          distance += x;
        }
      }
    }
    return [distance, fullKmSectionsList];
  };

  get2PointsDistance = function(pt1, pt2) {
    return getDistanceFromLatLonInKm(pt1['lat'], pt1['lon'], pt2['lat'], pt2['lon']);
  };

  getDistanceFromLatLonInKm = function(lat1, lon1, lat2, lon2) {
    var R, a, c, d, dlat, dlon;
    R = 6371;
    dlat = deg2rad(lat2 - lat1);
    dlon = deg2rad(lon2 - lon1);
    a = Math.sin(dlat / 2) * Math.sin(dlat / 2) + Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * Math.sin(dlon / 2) * Math.sin(dlon / 2);
    c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    d = R * c;
    return d;
  };

  deg2rad = function(deg) {
    return deg * (Math.PI / 180);
  };

  getPointOnSection = function(section, pt1ToFullKmDistance, ithKilometer) {
    var deltaLat, deltaLon, lat, lon, pt1ToIthKmDistance, sectionDistance;
    deltaLon = Number(section.endPoint['lon']) - Number(section.startPoint['lon']);
    deltaLat = Number(section.endPoint['lat']) - Number(section.startPoint['lat']);
    sectionDistance = get2PointsDistance(section.startPoint, section.endPoint);
    pt1ToIthKmDistance = pt1ToFullKmDistance + ithKilometer;
    lon = Math.abs(deltaLon) * pt1ToIthKmDistance / sectionDistance;
    lat = Math.abs(deltaLat) * pt1ToIthKmDistance / sectionDistance;
    if (deltaLon < 0) {
      lon = lon * -1;
    }
    if (deltaLat < 0) {
      lat = lat * -1;
    }
    return [Number(section.startPoint['lat']) + lat, Number(section.startPoint['lon']) + lon];
  };

  window.RoutesMapHandler = MapHandler;

}).call(this);
